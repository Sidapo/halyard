// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-
// @BEGIN_LICENSE
//
// Halyard - Multimedia authoring and playback system
// Copyright 1993-2009 Trustees of Dartmouth College
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// @END_LICENSE

// ScormAiccGwCtl.cpp : Implementation of CScormAiccGwCtl

#include "stdafx.h"
#include "ScormAiccGw.h"
#include "ScormAiccGwCtl.h"
#include "shlobj.h"           // for SHGetSpecialFolderPath()

#define MAX_KEY_LENGTH 255

const char* SUBKEY_PREFIX = "SOFTWARE\\ScormAiccBridge\\";
const char* TEMP_DIR_PREFIX = "SAB";
const char* ENV_VAR = "UNTRUSTED_COURSE_DATA";
const char* STARTUP_FILE = "PARAM.CMI";
const char* FINFILE_NAME = "finish.cmi";
const char* CMNTFILE_NAME = "cmnt.cmi";
const char* OBJTVFILE_NAME = "objtv.cmi";
const char* INTERFILE_NAME = "inter.cmi";
const char* PATHFILE_NAME = "path.cmi";
const char* PERFFILE_NAME = "perf.cmi";

/////////////////////////////////////////////////////////////////////////////
// CScormAiccGwCtl

CScormAiccGwCtl::CScormAiccGwCtl()
{
    m_szTmpDir[0] = 0;
   m_bWindowOnly = TRUE;
}

////////////////////////////////////////////////
//
// get & put methods for properties
//
////////////////////////////////////////////////
STDMETHODIMP CScormAiccGwCtl::get_CourseGUID(BSTR *pVal)
{
   *pVal = m_sCourseGUID.Copy();
    return S_OK;
}

STDMETHODIMP CScormAiccGwCtl::put_CourseGUID(BSTR newVal)
{
   m_sCourseGUID = newVal;
#if _DEBUG
   USES_CONVERSION;
   AtlTrace(_T("m_sCourseGUID is %s.\n"), OLE2T(m_sCourseGUID.Copy()));
#endif
   return S_OK;
}


STDMETHODIMP CScormAiccGwCtl::get_CourseParams(BSTR *pVal)
{
   *pVal = m_sCourseParams.Copy();
    return S_OK;
}

STDMETHODIMP CScormAiccGwCtl::put_CourseParams(BSTR newVal)
{
   m_sCourseParams = newVal;
#if _DEBUG
   USES_CONVERSION;
   AtlTrace(_T("m_sCourseParams is %s.\n"), OLE2T(m_sCourseParams.Copy()));
#endif
    return S_OK;
}
////////////////////////////////////////////////
//
// Overrides of inherited methods
// Generated by ATL wizard
//
////////////////////////////////////////////////
STDMETHODIMP CScormAiccGwCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IScormAiccGwCtl,
    };
    for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i], riid))
            return S_OK;
    }
    return S_FALSE;
}

LRESULT CScormAiccGwCtl::OnSetFocus (UINT uMsg, WPARAM wParam, LPARAM lParam, 
                                     BOOL& bHandled)
{
    LRESULT lRes = CComControl<CScormAiccGwCtl>::OnSetFocus(uMsg, wParam, 
                                                           lParam, bHandled);
    if (m_bInPlaceActive)
    {
        DoVerbUIActivate(&m_rcPos,  NULL);
        if(!IsChild(::GetFocus()))
            m_ctlButton.SetFocus();
    }
    return lRes;
}

//
// Handler to create the contained button window
// Put a label on the button
//
LRESULT CScormAiccGwCtl::OnCreate (UINT /*uMsg*/, WPARAM /*wParam*/,  
                                   LPARAM /*lParam*/, BOOL& /*bHandled*/)
{

   USES_CONVERSION;                       // for conversions of CComBSTR objs   

   //
   // Create the button window
   //
   RECT rc;
   GetWindowRect(&rc);
   rc.right -= rc.left;
   rc.bottom -= rc.top;
   rc.top = rc.left = 0;
   m_ctlButton.Create(_T("Button"), this, 1, m_hWnd, rc);
   m_ctlButton.EnableWindow (FALSE);      // disable until init complete
   m_ctlButton.ShowWindow (SW_HIDE);

   //
   // Open the registry key for this GUID
   //
   if (!OpenKeyForGUID())
   {
      CloseKeyForGUID();
      CComBSTR sErr = "Course with GUID ";
      sErr += m_sCourseGUID;
      sErr += " not installed";
      return Error (OLE2T(sErr));
   }

   //
   // retrieve the button label from the registry key
   //
   TCHAR szLabel[_MAX_PATH];
   DWORD dwBufLen = _MAX_PATH;
   LONG lRet;
   lRet = RegQueryValueEx (m_hKey,        // handle stored here
                           TEXT("Button label"),
                           NULL,
                           NULL,
                           (LPBYTE)szLabel,
                           &dwBufLen);
   if (lRet != ERROR_SUCCESS) 
      m_ctlButton.EnableWindow (FALSE);   // on error => button does nothing
   
   else                                   // put a label on the button
   {
      CComBSTR sButtonLab = "Launch ";
      CComBSTR sTemp = szLabel;
      sButtonLab += sTemp;
      lstrcpy (m_szButtonLab, OLE2T(sButtonLab));
      m_ctlButton.SetWindowText (m_szButtonLab);
   }

   //
   // Get the name of the app to launch
   //
   dwBufLen = _MAX_PATH;
   lRet = RegQueryValueEx (m_hKey,              // handle stored here
                           TEXT("App name"),
                           NULL,
                           NULL,
                           (LPBYTE)m_szAppName,
                           &dwBufLen);
   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   // 
   // C++ exceptions incompatible with ATL
   //
   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   if (lRet != ERROR_SUCCESS) 
   {
      CloseKeyForGUID();
      return Error (_T("Unable to find application name in registry"));
   }

   //
   // Get the command line
   //
   dwBufLen = _MAX_PATH;
   lRet = RegQueryValueEx (m_hKey,              // handle stored here
                           TEXT("Cmd line"),
                           NULL,
                           NULL,
                           (LPBYTE)m_szCmdLine,
                           &dwBufLen);
   if (lRet != ERROR_SUCCESS) 
   {
      CloseKeyForGUID();
      return Error (_T("Unable to find command line in registry"));
   }

   //
   // Get the working directory
   //   
   dwBufLen = _MAX_PATH;
   lRet = RegQueryValueEx (m_hKey,              // handle stored here
                           TEXT("Working dir"),
                           NULL,
                           NULL,
                           (LPBYTE)m_szWrkDir,
                           &dwBufLen);
   if (lRet != ERROR_SUCCESS) 
   {
      CloseKeyForGUID();
      return Error (_T("Unable to find name of working directory in registry"));
   }

   CloseKeyForGUID();                           // close the registry key

   m_ctlButton.EnableWindow (TRUE);             // enable button
   m_ctlButton.ShowWindow (SW_SHOW);

    return 0;

}

STDMETHODIMP CScormAiccGwCtl::SetObjectRects (LPCRECT /*prcPos*/,
                                              LPCRECT /*prcClip*/)
{
   SizeToLabel();                // size contained button window to text label
    return S_OK;
}

//
// Button click handler
// This puts the user in the loop, for security reasons,
// to launch the application.
// 
LRESULT CScormAiccGwCtl::OnClicked (UINT /*uMsg*/, WPARAM /*wParam*/, 
                                    LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
   
   m_ctlButton.EnableWindow (FALSE);      // this is a one-click-only button

    USES_CONVERSION;                       // for conversions of CComBSTR objs

   if (isMyCourseRunning())
      return Error (_T("There's an application already running"));

   //
   // Create a temporary directory for the 
   // params (startup) file
   //
   TCHAR StartupPath[_MAX_PATH];
   if (!CreateTempDir())
      return Error (_T("Unable to write startup file"));
   lstrcpy (StartupPath, m_szTmpDir);
   lstrcat (StartupPath, "\\");
   lstrcat (StartupPath, STARTUP_FILE);
   //
   // Write the file before launching app
   //
   HANDLE hFile = ::CreateFile (StartupPath,    // open params (startup) file
                                GENERIC_WRITE,  // in write-only mode
                                0,              // no sharing
                                NULL,           // ignore security attributes 
                                CREATE_ALWAYS,  // open; create if necessary 
                                FILE_ATTRIBUTE_NORMAL, 
                                NULL);          // ignore extended attributes
   if (hFile == INVALID_HANDLE_VALUE)
      return Error (_T("Unable to open startup file"));
   SetEndOfFile (hFile);                        // overwrite existing

   LPCSTR lpBuf = OLE2T(m_sCourseParams);       // get -> string within BSTR

   DWORD nBytesWritten;
   if (!WriteFile (hFile, lpBuf,                // write the text to the file
                   lstrlen (lpBuf), 
                   &nBytesWritten, NULL))
      return Error (_T("Unable to write startup file"));
   CloseHandle (hFile);                         // close file

   //
   // Prepare to launch app
   //
   STARTUPINFO StartUpInfo;
   PROCESS_INFORMATION ProcessInfo;

   StartUpInfo.cb = sizeof( StartUpInfo );
   StartUpInfo.lpReserved = NULL;
   StartUpInfo.dwFlags = 0;
   StartUpInfo.cbReserved2 = 0;
   StartUpInfo.lpReserved2 = NULL; 
   StartUpInfo.lpDesktop = NULL;
   StartUpInfo.lpTitle = NULL;
   StartUpInfo.dwX = 0;
   StartUpInfo.dwY = 0;
   StartUpInfo.dwXSize = 0;
   StartUpInfo.dwYSize = 0;
   StartUpInfo.dwXCountChars = 0;
   StartUpInfo.dwYCountChars = 0;
   StartUpInfo.dwFillAttribute = 0;
   StartUpInfo.dwFlags = 0;
   StartUpInfo.wShowWindow = 0;
   StartUpInfo.hStdInput = NULL;
   StartUpInfo.hStdOutput = NULL;
   StartUpInfo.hStdError = NULL;

   //
   // Concatenate argument list to app name to create
   // the command line.
   //
   CComBSTR sCmdLine = m_szAppName;
   sCmdLine += " ";
   sCmdLine += m_szCmdLine;

   //
   // Launch the app
   //
   if (!CreateProcess (NULL, OLE2T(sCmdLine), NULL, NULL, FALSE, 
                       NORMAL_PRIORITY_CLASS, NULL, (LPCTSTR) &m_szWrkDir, 
                       &StartUpInfo, &ProcessInfo))
   {
      DWORD myError = GetLastError();
      return Error (_T("Unable to launch application"));
   }
   m_hProcess = ProcessInfo.hProcess;        // save handle of launched process

   //
   // Set the hidden window's timer for
   // polling the state of the launched process
   //
   m_nTimer = m_ctlButton.SetTimer (1, 1000);        
    return 0;

}

////////////////////////////////////////////////
//
// My overrides
//
////////////////////////////////////////////////
HRESULT CScormAiccGwCtl::FinalConstruct()
{
    return S_OK;
}

void CScormAiccGwCtl::FinalRelease()
{
   if (!DestroyTempDir())        // remove temporary files before exiting
      AtlTrace(_T("unable to remove %s:\n"), m_szTmpDir);
}


////////////////////////////////////////////////
//
// Private methods
//
////////////////////////////////////////////////

//
// Looks for registry key corresponding to GUID
// that's passed as the argument.
// If key exists, open it and save its handle.
//
BOOL CScormAiccGwCtl::OpenKeyForGUID ()
{
   
   USES_CONVERSION;                       // for conversions of CComBSTR objs

   //
   // Do some crude validation to make
   // sure all characters in m_sCourseGUID
   // are either alphanumeric hexadecimal or '-'.
   //
   TCHAR sTemp[MAX_KEY_LENGTH];
   lstrcpy (sTemp, OLE2T(m_sCourseGUID.Copy()));
   TCHAR *ps = sTemp;
   while (*ps)
   {
      if (!IsCharAlphaNumeric (*ps) && *ps != '-')
         return FALSE;
      if (IsCharAlpha (*ps))
      {
         LPTSTR pS = CharUpper (ps);
         if (*pS < 'A' || *pS > 'F')
            return FALSE;
      }
      ps++;
   }
   
   CComBSTR sSubkey = SUBKEY_PREFIX;
   sSubkey += m_sCourseGUID;
   return (RegOpenKeyEx (HKEY_LOCAL_MACHINE, 
                         OLE2T(sSubkey), 0, KEY_QUERY_VALUE, &m_hKey) 
           == ERROR_SUCCESS); 

}

//
// Checks if launched process is running
//
BOOL CScormAiccGwCtl::isMyCourseRunning() 
{ 
   if (m_hProcess)                        // our copy of proc's handle
   {                                      //    NULL => not running
      DWORD ExitCode;
      ::GetExitCodeProcess (m_hProcess, &ExitCode);
      if (ExitCode != STILL_ACTIVE)
         m_hProcess = NULL;
   }
   return (m_hProcess != NULL);
}

//
// This private function creates a temporary 
// subdirectory according to the user's settings, e.g. 
// C:\Documents and Settings\<user>\Local Settings\Temp
//
// It returns TRUE if the temp directory is successfully created.
//
BOOL CScormAiccGwCtl::CreateTempDir()
{

   TCHAR Temp[_MAX_PATH];
   if (!GetTempPath (sizeof (Temp), Temp))
      return FALSE;

   ::GetTempFileName (Temp, TEMP_DIR_PREFIX, ::GetTickCount(), m_szTmpDir);

   SECURITY_ATTRIBUTES sa;
   sa.nLength = sizeof (SECURITY_ATTRIBUTES);
   sa.lpSecurityDescriptor = NULL;
   sa.bInheritHandle = FALSE;
   BOOL bOK = CreateDirectory (m_szTmpDir, &sa);
   if (bOK)
      SetEnvironmentVariable (ENV_VAR, m_szTmpDir);
   return bOK;

}

//
// This private function destroys the temporary 
// subdirectory.
//
// It returns TRUE if the temp directory is successfully destroyed.
//
BOOL CScormAiccGwCtl::DestroyTempDir()
{

   if (!m_szTmpDir[0])
      return FALSE;

   AtlTrace(_T("temp dir %s:\n"), m_szTmpDir);
   SetCurrentDirectory (m_szTmpDir);

   //
   // Need to remove all files in dir
   // before dir can be removed.
   //
   WIN32_FIND_DATA FindFileData;
   HANDLE hFind;
   TCHAR sPath[_MAX_PATH];
   lstrcpy (sPath, m_szTmpDir);
   lstrcat (sPath, "\\");
   lstrcat (sPath, "*.*");
   hFind = FindFirstFile(sPath, &FindFileData);
   if (DeleteFile (FindFileData.cFileName))
      AtlTrace(_T("\t%s deleted\n"), FindFileData.cFileName);
   while (FindNextFile (hFind, &FindFileData))
   {
      if (DeleteFile (FindFileData.cFileName))
         AtlTrace(_T("\t%s deleted\n"), FindFileData.cFileName);
   }
   FindClose(hFind);

   //
   // now remove the directory
   //
   SetCurrentDirectory ("..");
   return RemoveDirectory (m_szTmpDir);

}

//
// This private function automatically resizes the 
// contained button to fit the label 
//
void CScormAiccGwCtl::SizeToLabel()
{

   HDC hDC = m_ctlButton.GetDC();
   SIZE BtnSize;                          // height & width in logical units
   ::GetTextExtentPoint32 (hDC, m_szButtonLab, lstrlen (m_szButtonLab), &BtnSize);
   int BtnWidth = static_cast <int> (1.3 * BtnSize.cx);
   int BtnHeight = static_cast <int> (BtnWidth/4);
   m_ctlButton.SetWindowPos (NULL, 0, 0, BtnWidth, BtnHeight,
                             SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);

}



////////////////////////////////////////////////
//
// IDispatch methods
//
////////////////////////////////////////////////

STDMETHODIMP CScormAiccGwCtl::isCourseInstalled (BOOL *pbSuccess)
{
   *pbSuccess = OpenKeyForGUID(); 
   CloseKeyForGUID();
    return S_OK;
}

STDMETHODIMP CScormAiccGwCtl::GetFileContent(unsigned int nID, BSTR *psContent)
{

    USES_CONVERSION;                       // for conversions of CComBSTR objs

   //
   // Construct the name of the path to the output file.
   // Located in <user's application data>\<temp dir>
   //
   TCHAR Path[_MAX_PATH];
   lstrcpy (Path, m_szTmpDir);
   lstrcat (Path, "\\");

   switch (nID)
   {
      case Finish:
         lstrcat (Path, FINFILE_NAME);
         break;
      case Comments:
         lstrcat (Path, CMNTFILE_NAME);
         break;
      case Objectives:
         lstrcat (Path, OBJTVFILE_NAME);
         break;
      case Interactions:
         lstrcat (Path, INTERFILE_NAME);
         break;
      case Paths:
         lstrcat (Path, PATHFILE_NAME);
         break;
      case Performance:
         lstrcat (Path, PERFFILE_NAME);
         break;
      default:
         return Error (_T("Invalid output file ID"));
   }

   //
   // Open the output file
   //
   HANDLE hFile = CreateFile (Path,             // open file
                              GENERIC_READ,     // in read-only mode
                              0,                // no sharing
                              NULL,             // ignore security attributes 
                              OPEN_EXISTING,    // open if it exists 
                              FILE_ATTRIBUTE_NORMAL, 
                              NULL);            // ignore extended attributes
   if (hFile == INVALID_HANDLE_VALUE)
      return Error (_T("Unable to open output file"));

   TCHAR buf[1024];
   DWORD nBytesRead;
   CComBSTR sTmp;
   do 
   {
      memset (buf, 0, sizeof(buf));
      if (ReadFile (hFile, buf, sizeof(buf),    // read a block at a time
                    &nBytesRead, NULL))
         sTmp += buf;                           // stuff into BSTR
      else
      {
         return Error (_T("Error reading output file"));
         CloseHandle (hFile);
      }
   } 
   while (nBytesRead == sizeof(buf));           // until no more
   CloseHandle (hFile);                         // close file
#if !_DEBUG
   DeleteFile (Path);                           // delete it
#endif
      
   *psContent = (BSTR)sTmp;
   //AtlTrace("%s", OLE2T(*psContent));         // limited to 512 chars

    return S_OK;
}

LRESULT CScormAiccGwCtl::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   if (m_hProcess &&                      // if course was running last check
      !isMyCourseRunning())               //    but now it's stopped
   {
      m_ctlButton.KillTimer(m_nTimer);    // stop the timer (must be done before event)
      Fire_AppTerminated();               // fire an event for the client
   }
    bHandled=TRUE;
    return 0;
}

