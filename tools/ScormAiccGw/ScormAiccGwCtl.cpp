// ScormAiccGwCtl.cpp : Implementation of CScormAiccGwCtl

#include "stdafx.h"
#include "ScormAiccGw.h"
#include "ScormAiccGwCtl.h"

const char* SUBKEY_PREFIX = "SOFTWARE\\ScormAiccBridge\\";
const char* STARTUP_FILE = "PARAM.CMI";
const char* TEMP_DIR = "temp";               // subdir of Windows dir where 
                                             // output files placed temporarily
const char* FINFILE_NAME = "finish.cmi";
const char* CMNTFILE_NAME = "cmnt.cmi";
const char* OBJTVFILE_NAME = "objtv.cmi";
const char* INTERFILE_NAME = "inter.cmi";
const char* PATHFILE_NAME = "path.cmi";
const char* PERFFILE_NAME = "perf.cmi";

#if HIDDEN_WINDOW
/////////////////////////////////////////////////////////////////////////////
// CWinHidden

LRESULT CHiddenWindow::OnTimer (UINT uMsg, WPARAM wParam, LPARAM lParam, 
                                BOOL& bHandled)
{
	m_pCtl->OnTimer (uMsg, wParam, lParam, bHandled);
	return 0;
}
#endif


/////////////////////////////////////////////////////////////////////////////
// CScormAiccGwCtl

////////////////////////////////////////////////
//
// Overrides of inherited methods
// Generated by ATL wizard
//
////////////////////////////////////////////////
HRESULT CScormAiccGwCtl::OnDraw(ATL_DRAWINFO& di)
{
	RECT& rc = *(RECT*)di.prcBounds;
	Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

	SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
	LPCTSTR pszText = _T("ATL 3.0 : ScormAiccGwCtl");
	TextOut(di.hdcDraw, 
		(rc.left + rc.right) / 2, 
		(rc.top + rc.bottom) / 2, 
		pszText, 
		lstrlen(pszText));

	return S_OK;
}

STDMETHODIMP CScormAiccGwCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IScormAiccGwCtl,
	};
	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}
	return S_FALSE;
}

////////////////////////////////////////////////
//
// My overrides
//
////////////////////////////////////////////////
HRESULT CScormAiccGwCtl::FinalConstruct()
{
#if HIDDEN_WINDOW

	RECT rect;
	m_hHidden = m_wndHidden.Create(NULL, rect);
   m_uintTimer = ::SetTimer(m_hHidden, 1, 1000, NULL);
#endif
	return S_OK;
}

void CScormAiccGwCtl::FinalRelease()
{
#if HIDDEN_WINDOW
	::KillTimer (m_hHidden, 1);
	m_wndHidden.DestroyWindow();
#endif
}


////////////////////////////////////////////////
//
// Private methods
//
////////////////////////////////////////////////

//
// Looks for registry key corresponding to GUID
// that's passed as the argument.
// If key exists, open it and save its handle.
//
BOOL CScormAiccGwCtl::OpenKeyForGUID (BSTR sCourseGuid)
{
   
	USES_CONVERSION;                       // for conversions of CComBSTR objs
   CComBSTR sSubkey = SUBKEY_PREFIX;
   sSubkey += sCourseGuid;
   return (RegOpenKeyEx (HKEY_LOCAL_MACHINE, 
                         OLE2T(sSubkey), 0, KEY_QUERY_VALUE, &m_hKey) 
           == ERROR_SUCCESS); 

}

//
// Checks if launched process is running
//
BOOL CScormAiccGwCtl::isMyCourseRunning() 
{ 
   if (m_hProcess)                        // our copy of proc's handle
   {                                      //    NULL => not running
      DWORD ExitCode;
      ::GetExitCodeProcess (m_hProcess, &ExitCode);
      if (ExitCode != STILL_ACTIVE)
         m_hProcess = NULL;
   }
   return (m_hProcess != NULL);
}

////////////////////////////////////////////////
//
// IDispatch methods
//
////////////////////////////////////////////////

STDMETHODIMP CScormAiccGwCtl::isCourseInstalled (BSTR sCourseGuid, 
                                                 BOOL *pbSuccess)
{
   *pbSuccess = OpenKeyForGUID (sCourseGuid); 
   CloseKeyForGUID();
	return S_OK;
}

STDMETHODIMP CScormAiccGwCtl::launchCourse(BSTR sCourseGUID, BSTR sParams)
{

   LONG lRet;

	USES_CONVERSION;                       // for conversions of CComBSTR objs

   if (isMyCourseRunning())
      return Error (_T("There's an application already running"));

   //
   // Open the registry key for this GUID
   //
   if (!OpenKeyForGUID (sCourseGUID))
   {
      CloseKeyForGUID();
      CComBSTR sErr = "Course with GUID ";
      sErr += sCourseGUID;
      sErr += " not installed";
      return Error (OLE2T(sErr));
   }

   //
   // Get the name of the app to launch
   //
   DWORD dwBufLen = _MAX_PATH;
   lRet = RegQueryValueEx (m_hKey,              // handle stored here
                           TEXT("App name"),
                           NULL,
                           NULL,
                           (LPBYTE)m_szAppName,
                           &dwBufLen);
   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   // 
   // C++ exceptions incompatible with ATL
   //
   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   if (lRet != ERROR_SUCCESS) 
   {
      CloseKeyForGUID();
      return Error (_T("Unable to find application name in registry"));
   }

   //
   // Get the command line
   //
   dwBufLen = _MAX_PATH;
   lRet = RegQueryValueEx (m_hKey,              // handle stored here
                           TEXT("Cmd line"),
                           NULL,
                           NULL,
                           (LPBYTE)m_szCmdLine,
                           &dwBufLen);
   if (lRet != ERROR_SUCCESS) 
   {
      CloseKeyForGUID();
      return Error (_T("Unable to find command line in registry"));
   }

   //
   // Get the working directory
   //   
   dwBufLen = _MAX_PATH;
   lRet = RegQueryValueEx (m_hKey,              // handle stored here
                           TEXT("Working dir"),
                           NULL,
                           NULL,
                           (LPBYTE)m_szWrkDir,
                           &dwBufLen);
   if (lRet != ERROR_SUCCESS) 
   {
      CloseKeyForGUID();
      return Error (_T("Unable to find name of working directory in registry"));
   }

   CloseKeyForGUID();                           // close the registry key
   m_sCourseGUID = sCourseGUID;                 // save the course GUID

   //
   // Construct the name of the params (startup) file
   // Located in the windows directory
   //
   TCHAR StartupPath[_MAX_PATH];
   if (GetWindowsDirectory (StartupPath, sizeof(StartupPath)) == 0)
      return Error (_T("Unable to open startup file"));
   lstrcat (StartupPath, "\\");
   lstrcat (StartupPath, STARTUP_FILE);
   //
   // Write the file before launching app
   //
   HANDLE hFile = CreateFile (StartupPath,      // open params (startup) file
                              GENERIC_WRITE,    // in write-only mode
                              0,                // no sharing
                              NULL,             // ignore security attributes 
                              CREATE_ALWAYS,    // open; create if necessary 
                              FILE_ATTRIBUTE_NORMAL, 
                              NULL);            // ignore extended attributes
   if (hFile == INVALID_HANDLE_VALUE)
      return Error (_T("Unable to open startup file"));
   SetEndOfFile (hFile);                        // overwrite existing
   LPCSTR lpBuf = OLE2T(sParams);
   DWORD nBytesWritten;
   if (!WriteFile (hFile, lpBuf,                // write the text to the file
                   lstrlen (lpBuf), 
                   &nBytesWritten, NULL))
      return Error (_T("Unable to write startup file"));
   CloseHandle (hFile);                         // close file

   //
   // Prepare to launch app
   //
   STARTUPINFO StartUpInfo;
   PROCESS_INFORMATION ProcessInfo;

   StartUpInfo.cb = sizeof( StartUpInfo );
   StartUpInfo.lpReserved = NULL;
   StartUpInfo.dwFlags = 0;
   StartUpInfo.cbReserved2 = 0;
   StartUpInfo.lpReserved2 = NULL; 
   StartUpInfo.lpDesktop = NULL;
   StartUpInfo.lpTitle = NULL;
   StartUpInfo.dwX = 0;
   StartUpInfo.dwY = 0;
   StartUpInfo.dwXSize = 0;
   StartUpInfo.dwYSize = 0;
   StartUpInfo.dwXCountChars = 0;
   StartUpInfo.dwYCountChars = 0;
   StartUpInfo.dwFillAttribute = 0;
   StartUpInfo.dwFlags = 0;
   StartUpInfo.wShowWindow = 0;
   StartUpInfo.hStdInput = NULL;
   StartUpInfo.hStdOutput = NULL;
   StartUpInfo.hStdError = NULL;

   //
   // Concatenate argument list to app name to create
   // the command line.
   //
   CComBSTR sCmdLine = m_szAppName;
   sCmdLine += " ";
   sCmdLine += m_szCmdLine;

   //
   // Launch the app
   //
   if (!CreateProcess (NULL, OLE2T(sCmdLine), NULL, NULL, FALSE, 
                       NORMAL_PRIORITY_CLASS, NULL, (LPCTSTR) &m_szWrkDir, 
                       &StartUpInfo, &ProcessInfo))
   {
      DWORD myError = GetLastError();
      return Error (_T("Unable to launch application"));
   }
   m_hProcess = ProcessInfo.hProcess;        // save handle of launched process

   //SetTimer (1, 1000);
         
	return S_OK;

}

//
// This method provides a convenient handler 
// that allows the client to "poll" the state 
// of the launched application.
// If the course  
STDMETHODIMP CScormAiccGwCtl::onIdle()
{
   if (m_hProcess &&                      // if course was running last check
      !isMyCourseRunning())               //    but now it's stopped
   {
      Fire_AppTerminated();               // fire an event for the client
   }
	return S_OK;
}

STDMETHODIMP CScormAiccGwCtl::GetFileContent(unsigned int nID, BSTR *psContent)
{

	USES_CONVERSION;                       // for conversions of CComBSTR objs

   //
   // Construct the name of the path to the output files directory.
   // Located in <windows directory>\<TEMP_DIR>
   //
   TCHAR Path[_MAX_PATH];
   if (GetWindowsDirectory (Path, sizeof(Path)) == 0)
      return Error (_T("Unable to open output file"));
   lstrcat (Path, "\\");
   lstrcat (Path, TEMP_DIR);
   lstrcat (Path, "\\");

   switch (nID)
   {
      case Finish:
         lstrcat (Path, FINFILE_NAME);
         break;
      case Comments:
         lstrcat (Path, CMNTFILE_NAME);
         break;
      case Objectives:
         lstrcat (Path, OBJTVFILE_NAME);
         break;
      case Interactions:
         lstrcat (Path, INTERFILE_NAME);
         break;
      case Paths:
         lstrcat (Path, PATHFILE_NAME);
         break;
      case Performance:
         lstrcat (Path, PERFFILE_NAME);
         break;
      default:
         return Error (_T("Invalid output file ID"));
   }

   //
   // Open the output file
   //
   HANDLE hFile = CreateFile (Path,             // open file
                              GENERIC_READ,     // in read-only mode
                              0,                // no sharing
                              NULL,             // ignore security attributes 
                              OPEN_EXISTING,    // open if it exists 
                              FILE_ATTRIBUTE_NORMAL, 
                              NULL);            // ignore extended attributes
   if (hFile == INVALID_HANDLE_VALUE)
      return Error (_T("Unable to open output file"));

   TCHAR buf[1024];
   DWORD nBytesRead;
   CComBSTR sTmp;
   do 
   {
      memset (buf, 0, sizeof(buf));
      if (ReadFile (hFile, buf, sizeof(buf),    // read a block at a time
                    &nBytesRead, NULL))
         sTmp += buf;                           // stuff into BSTR
      else
      {
         return Error (_T("Error reading output file"));
         CloseHandle (hFile);
      }
   } 
   while (nBytesRead == sizeof(buf));           // until no more
   CloseHandle (hFile);                         // close file
#if !_DEBUG
   DeleteFile (Path);                           // delete it
#endif
      
   *psContent = (BSTR)sTmp;
   //AtlTrace("%s", OLE2T(*psContent));         // limited to 512 chars

	return S_OK;
}

LRESULT CScormAiccGwCtl::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
#if 0
   KillTimer(wParam);
#endif
	bHandled=TRUE;
	return 0;
}

